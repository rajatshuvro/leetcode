using System;
using System.Collections.Generic;

namespace Problems.Graphs
{
    public class MalwareSpreadTwo
    {
        //https://leetcode.com/problems/minimize-malware-spread-ii/
        private int[][] _component;
        private int[][] _graph;
        public int MinMalwareSpread(int[][] graph, int[] initial)
        {
            if (initial == null || initial.Length == 0) return 0;
            _graph = graph;
            var nodeComponent = new int[graph.Length];
            var spreadCount = new int[graph.Length];
            Array.Fill(nodeComponent, -1);//all nodes are initially un-assigned
            Array.Fill(spreadCount, -1);

            var componentSizes = new Dictionary<int, int>();
            Array.Sort(initial);

            var compNum = graph.Length + 1;
            var v = GetNextUnGroupedNode(nodeComponent, 0);
            while (v >= 0)
            {
                var size = AssignComponent(graph,v, compNum, nodeComponent);
                componentSizes.Add(compNum, size);
                compNum++;
                v = GetNextUnGroupedNode(nodeComponent, v+1);
            }
            //nodes have been assigned to components. Getting component initializers
            var componentInitializers = GetComponentInitializers(nodeComponent, initial);
            // finding spread for components with one initializer is easy
            InitializeComponent(graph.Length);
            foreach (var (comp, initializers) in componentInitializers)
            {
                if(initializers.Count > 1) {
                    //component with > 1 initializer
                    ClearComponent();
                    var root1 = initializers[0];
                    var root2 = initializers[1];
                    foreach (var i in initializers)
                    {
                        var compNodes = GetComponentNodes(nodeComponent, comp);
                        GetComponentWithoutNode(compNodes, i);
                        var root = i == root1 ? root2 : root1;
                        var compSize = AssignComponent(_component, root, int.MaxValue, new int[graph.Length]);
                        spreadCount[i] = compNodes.Count - compSize - 1;
                    }
                }
                else spreadCount[initializers[0]] = componentSizes[comp] - 1;
            }

            return GetMaxInfector(spreadCount, initial);
        }

        private int GetMaxInfector(int[] spreadCount, int[] initial)
        {
            var maxInfectionCount = 0;
            var maxInfector = initial[0];
            for (int i = 0; i < initial.Length; i++)
            {
                var v = initial[i];
                if (spreadCount[v] > maxInfectionCount)
                {
                    maxInfectionCount = spreadCount[v];
                    maxInfector = v;
                }
            }

            return maxInfector;
        }

        private List<int> GetComponentNodes(int[] nodeComponent, int comp)
        {
            var nodeSet = new List<int>();
            for (int i = 0; i < nodeComponent.Length; i++)
            {
                if(nodeComponent[i]==comp) nodeSet.Add(i);
            }

            return nodeSet;
        }

        private void InitializeComponent(int n)
        {
            _component = new int[n][];
            for (int i = 0; i < n; i++)
            {
                _component[i]= new int[n];
            }

        }
        
        private void ClearComponent()
        {
            var n = _component.Length;
            for (int i = 0; i < n; i++)
            {
                Array.Fill(_component[i], 0);
            }

        }

        private void GetComponentWithoutNode(List<int> nodeSet, int x)
        {
            foreach (var v in nodeSet)
            {
                if(v == x) continue;//skipping column for node x
                Array.Copy(_graph[v], _component[v], _graph[v].Length);
                _component[v][x] = 0;//removing node x;
            }
        }

        private Dictionary<int, List<int>> GetComponentInitializers(int[] nodeComponent, int[] initial)
        {
            var compInitializers= new Dictionary<int, List<int>>();
            for (int i = 0; i < initial.Length; i++)
            {
                var v = initial[i];
                var compNum = nodeComponent[v];
                if(! compInitializers.ContainsKey(compNum)) compInitializers[compNum] = new List<int>();
                compInitializers[compNum].Add(v);
            }

            return compInitializers;
        }

        private int AssignComponent(int[][] graph, int root, int compNum, int[] nodeComponent)
        {
            var stack = new Stack<int>();
            stack.Push(root);
            var size = 0;
            //assign each node to a group with DFS
            while (stack.Count > 0)
            {
                var v = stack.Pop();
                nodeComponent[v] = compNum;
                size++;
                //propagating to it's neighbors
                for (var i = 0; i < graph[v].Length; i++)
                {
                    if(graph[v][i]!=1) continue;
                    // i is the neighbor
                    if (nodeComponent[i] != compNum) stack.Push(i);
                }
            }

            return size;
        }
        private int GetNextUnGroupedNode(int[] nodeComponent, int i)
        {
            while (i < nodeComponent.Length)
            {
                if (nodeComponent[i] == -1) return i;
                i++;
            }

            return -1;
        }
    }
}