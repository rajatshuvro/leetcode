using System;
using System.Collections.Generic;

namespace Problems
{
    public class MalwareSpreadOne
    {
        //https://leetcode.com/problems/minimize-malware-spread/
        public int MinMalwareSpread(int[][] graph, int[] initial) {
            var nodeComponent = new int[graph.Length];
            Array.Fill(nodeComponent, -1);//no group assigned
            var componentSizes = new Dictionary<int, int>();

            var compNum = graph.Length + 1;
            var v = GetNextUnGroupedNode(nodeComponent, 0);
            while (v >= 0)
            {
                var size = AssignComponent(graph,v, compNum, nodeComponent);
                componentSizes.Add(compNum, size);
                compNum++;
                v = GetNextUnGroupedNode(nodeComponent, v+1);
            }

            //get all the initial nodes for a component
            var componentInitializers = GetComponentInitializers(initial, nodeComponent);
            var soleInfectionCounts = GetSoleInfectionCounts(graph, initial, nodeComponent, componentInitializers, componentSizes);

            //getting the node that infects the max.
            return GetMaxInfecter(initial, soleInfectionCounts);
        }

        private static int GetMaxInfecter(int[] initial, int[] soleInfectionCounts)
        {
            var maxInfecter = initial[0];
            var maxInfection = soleInfectionCounts[maxInfecter];
            for (int i = 0; i < initial.Length; i++)
            {
                var initialNode = initial[i];
                if (maxInfection == soleInfectionCounts[initialNode] && initialNode < maxInfecter)
                {
                    maxInfecter = initialNode;
                    continue;
                }

                if (maxInfection >= soleInfectionCounts[initialNode]) continue;

                maxInfecter = initialNode;
                maxInfection = soleInfectionCounts[maxInfecter];
            }

            return maxInfecter;
        }

        private static int[] GetSoleInfectionCounts(int[][] graph, int[] initial, int[] nodeComponent,
            Dictionary<int, List<int>> componentInitializers, Dictionary<int, int> componentSizes)
        {
            var soleInfectionCount = new int[graph.Length];
            foreach (var node in initial)
            {
                var component = nodeComponent[node];
                if (componentInitializers[component].Count > 1) soleInfectionCount[node] = 0;
                else soleInfectionCount[node] = componentSizes[component];
            }

            return soleInfectionCount;
        }

        private static Dictionary<int, List<int>> GetComponentInitializers(int[] initial, int[] nodeComponent)
        {
            var componentInitializers = new Dictionary<int, List<int>>();
            for (int i = 0; i < initial.Length; i++)
            {
                var initializer = initial[i];
                var component = nodeComponent[initializer];
                if (componentInitializers.TryGetValue(component, out var initializers)) initializers.Add(initializer);
                else componentInitializers.Add(component, new List<int>() {initializer});
            }

            return componentInitializers;
        }

        private int AssignComponent(int[][] graph, int root, int compNum, int[] nodeComponent)
        {
            var stack = new Stack<int>();
            stack.Push(root);
            var size = 0;
            //assign each node to a group with DFS
            while (stack.Count > 0)
            {
                var v = stack.Pop();
                nodeComponent[v] = compNum;
                size++;
                //propagating to it's neighbors
                for (var i = 0; i < graph[v].Length; i++)
                {
                    if(graph[v][i]!=1) continue;
                    // i is the neighbor
                    if (nodeComponent[i] != compNum) stack.Push(i);
                }
            }

            return size;
        }

        private int GetNextUnGroupedNode(int[] nodeComponent, int i)
        {
            while (i < nodeComponent.Length)
            {
                if (nodeComponent[i] == -1) return i;
                i++;
            }

            return -1;
        }
    }
}